diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index f7558bb5d86f03756f77f903e3a64bfdb6b73252..00376e62ced761ad520518a444ffe759f4d3e35b 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -5,7 +5,7 @@ IMPORTLIB = ntdll
 IMPORTS   = $(TOMCRYPT_PE_LIBS) $(MUSL_PE_LIBS)
 EXTRAINCL = $(TOMCRYPT_PE_CFLAGS)
 UNIX_CFLAGS  = $(UNWIND_CFLAGS)
-UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS)
+UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lmemory-patches
 
 EXTRADLLFLAGS = -nodefaultlibs
 i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 3969c2bb8989369f5e7de6dc93ced14b1e879c30..8201318113c14ee4b4f965fcaf9ceb1a0a936c63 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1184,6 +1184,32 @@ done:
     return ret;
 }
 
+int server_get_fd_for_address(const void *base, int *fd)
+{
+    int ret = -1;
+    obj_handle_t fd_handle;
+
+    *fd = -1;
+
+    SERVER_START_REQ( get_fd_for_address )
+    {
+        req->process = wine_server_obj_handle( GetCurrentProcess() );
+        req->addr = wine_server_client_ptr( base );
+        req->handle = 0;
+
+        if (!(ret = wine_server_call( req )))
+        {
+            if ((*fd = receive_fd( &fd_handle )) == -1)
+            {
+                ret = STATUS_TOO_MANY_OPENED_FILES;
+            }
+        }
+    }
+    SERVER_END_REQ;
+
+    return ret;
+}
+
 
 /***********************************************************************
  *           wine_server_fd_to_handle
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index d1e96be3a19da36b7ce841e508bf997fc0a7813e..a3c1d4db06c1e069649b1d6b9b163d90b9d8dfe7 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -36,6 +36,9 @@
 #include <sys/time.h>
 #include <time.h>
 #include <dirent.h>
+
+# include <libmemory-patches.h>
+
 #ifdef HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
@@ -2293,33 +2296,11 @@ static void get_performance_info( SYSTEM_PERFORMANCE_INFORMATION *info )
 
 #ifdef linux
     {
-        FILE *fp;
-
-        if ((fp = fopen("/proc/meminfo", "r")))
-        {
-            unsigned long long value, mem_available = 0;
-            char line[64];
-
-            while (fgets(line, sizeof(line), fp))
-            {
-                if(sscanf(line, "MemTotal: %llu kB", &value) == 1)
-                    totalram += value * 1024;
-                else if(sscanf(line, "MemFree: %llu kB", &value) == 1)
-                    freeram += value * 1024;
-                else if(sscanf(line, "SwapTotal: %llu kB", &value) == 1)
-                    totalswap += value * 1024;
-                else if(sscanf(line, "SwapFree: %llu kB", &value) == 1)
-                    freeswap += value * 1024;
-                else if (sscanf(line, "Buffers: %llu", &value))
-                    freeram += value * 1024;
-                else if (sscanf(line, "Cached: %llu", &value))
-                    freeram += value * 1024;
-                else if (sscanf(line, "MemAvailable: %llu", &value))
-                    mem_available = value * 1024;
-            }
-            fclose(fp);
-            if (mem_available) freeram = mem_available;
-        }
+        struct current_memory_info current_mem_values = get_current_memory_info();
+        totalram = current_mem_values.totalram;
+        freeram = current_mem_values.freeram;
+        totalswap = current_mem_values.totalswap;
+        freeswap = current_mem_values.freeswap;
     }
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || \
     defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 721bdeda08a60bf56f0e3864e95400eadbe24d5b..93530c6920b6b4ba00014c64198db883e0db062e 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -233,6 +233,7 @@ extern unsigned int server_queue_process_apc( HANDLE process, const union apc_ca
                                               union apc_result *result );
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
+extern int server_get_fd_for_address(const void *base, int *fd);
 extern void wine_server_send_fd( int fd );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index f82929ef57f757af2f8876071f7e845e88931982..3722ed3e3e415491a9fef400f7a40d2eff608dbd 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -92,6 +92,8 @@
 #include "unix_private.h"
 #include "wine/debug.h"
 
+#include <libmemory-patches.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(virtual);
 WINE_DECLARE_DEBUG_CHANNEL(module);
 WINE_DECLARE_DEBUG_CHANNEL(virtual_ranges);
@@ -267,6 +269,13 @@ void *anon_mmap_fixed( void *start, size_t size, int prot, int flags )
     assert( !((UINT_PTR)start & host_page_mask) );
     assert( !(size & host_page_mask) );
 
+    BOOL write_requested = has_write_flags(prot);
+    if (overcommit_prevention_enabled() && write_requested && memory_available_for_commit(size) == FALSE)
+    {
+        WARN("Prevented memory mapping due to insufficient memory.\n");
+        errno = ENOMEM;
+        return MAP_FAILED;
+    }
     return mmap( start, size, prot, MAP_PRIVATE | MAP_ANON | MAP_FIXED | flags, -1, 0 );
 }
 
@@ -275,6 +284,13 @@ void *anon_mmap_alloc( size_t size, int prot )
 {
     assert( !(size & host_page_mask) );
 
+    BOOL write_requested = has_write_flags(prot);
+    if (overcommit_prevention_enabled() && write_requested && memory_available_for_commit(size) == FALSE)
+    {
+        WARN("Prevented memory mapping due to insufficient memory.\n");
+        errno = ENOMEM;
+        return MAP_FAILED;
+    }
     return mmap( NULL, size, prot, MAP_PRIVATE | MAP_ANON, -1, 0 );
 }
 
@@ -589,6 +605,14 @@ static size_t unmap_area_above_user_limit( void *addr, size_t size )
 static void *anon_mmap_tryfixed( void *start, size_t size, int prot, int flags )
 {
     void *ptr;
+    BOOL write_requested = has_write_flags(prot);
+    
+    if (overcommit_prevention_enabled() && write_requested && memory_available_for_commit(size) == FALSE)
+    {
+        WARN("Prevented memory mapping due to insufficient memory.\n");
+        errno = ENOMEM;
+        return MAP_FAILED;
+    }
 
 #ifdef MAP_FIXED_NOREPLACE
     ptr = mmap( start, size, prot, MAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_ANON | flags, -1, 0 );
@@ -1981,14 +2005,43 @@ static int mprotect_range( void *base, size_t size, BYTE set, BYTE clear )
  */
 static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vprot )
 {
+    int fd = -1;
+    int ret = -1;
+    void *remapped = NULL;
+
     if (!use_kernel_writewatch && view->protect & VPROT_WRITEWATCH)
     {
+        /* 
+         * TODO: Figure out how to handle this case before attempting
+         *       to upstream the copy-on-write patch.
+         */
+
         /* each page may need different protections depending on write watch flag */
         set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~VPROT_WRITEWATCH );
     }
     else
     {
         if (enable_write_exceptions && is_vprot_exec_write( vprot )) vprot |= VPROT_WRITEWATCH;
+
+        /* Check if write copy was added to the mapping */
+        if ((vprot & VPROT_WRITECOPY) && !(view->protect & VPROT_WRITECOPY))
+        {
+            /* Get the associated file descriptor for the mapping */
+            ret = server_get_fd_for_address(view->base, &fd);
+
+            if (fd != -1 && ret == STATUS_SUCCESS)
+            {
+                /* Remap as copy-on-write using mmap() */
+                remapped = mmap(base, size, get_unix_prot(vprot), MAP_PRIVATE | MAP_FIXED, fd, 0);
+                close(fd);
+
+                if(remapped == base) return TRUE;
+                ERR("mmap() failed. Error: %s\n", strerror(errno));
+            }
+
+            ERR("Could not remap file as copy-on-write. Falling back to mprotect() instead\n");
+        }
+
         set_page_vprot( base, size, vprot );
     }
     return !mprotect_range( base, size, 0, 0 );
@@ -3476,6 +3529,7 @@ static unsigned int virtual_map_section( HANDLE handle, PVOID *addr_ptr, ULONG_P
     HANDLE shared_file;
     LARGE_INTEGER offset;
     sigset_t sigset;
+    BOOL write_consumes_memory = FALSE;
 
     switch(protect)
     {
@@ -3551,6 +3605,16 @@ static unsigned int virtual_map_section( HANDLE handle, PVOID *addr_ptr, ULONG_P
 
     if ((res = server_get_unix_fd( handle, 0, &unix_handle, &needs_close, NULL, NULL ))) return res;
 
+    /* determine whether writing to the view will consume physical memory */
+    write_consumes_memory = (protect == PAGE_WRITECOPY || protect == PAGE_EXECUTE_WRITECOPY);
+
+    /* if overcommit prevention is enabled then verify that we can satisfy any page commit requests */
+    if (write_consumes_memory && overcommit_prevention_enabled() && memory_available_for_commit(size) == FALSE)
+    {
+        WARN("Prevented page overcommit due to insufficient memory.\n");
+        return STATUS_NO_MEMORY;
+    }
+
     server_enter_uninterrupted_section( &virtual_mutex, &sigset );
 
     res = map_view( &view, base, size, alloc_type, vprot, limit_low, limit_high, 0 );
@@ -3581,6 +3645,11 @@ static unsigned int virtual_map_section( HANDLE handle, PVOID *addr_ptr, ULONG_P
         *addr_ptr = view->base;
         *size_ptr = size;
         VIRTUAL_DEBUG_DUMP_VIEW( view );
+
+        /* if overcommit prevention is enabled and we performed a commit, then touch the commited pages */
+        if (write_consumes_memory && overcommit_prevention_enabled()) {
+            touch_committed_pages(view->base, size, protect);
+        }
     }
     else delete_view( view );
 
@@ -4966,6 +5035,13 @@ static NTSTATUS allocate_virtual_memory( void **ret, SIZE_T *size_ptr, ULONG typ
     if (type & MEM_RESERVE_PLACEHOLDER && (protect != PAGE_NOACCESS)) return STATUS_INVALID_PARAMETER;
     if (!arm64ec_view && (attributes & MEM_EXTENDED_PARAMETER_EC_CODE)) return STATUS_INVALID_PARAMETER;
 
+    /* if overcommit prevention is enabled then verify that we can satisfy any page commit requests */
+    if ((type & MEM_COMMIT) && overcommit_prevention_enabled() && memory_available_for_commit(size) == FALSE)
+    {
+        WARN("Prevented page overcommit due to insufficient memory.\n");
+        return STATUS_NO_MEMORY;
+    }
+
     /* Reserve the memory */
 
     server_enter_uninterrupted_section( &virtual_mutex, &sigset );
@@ -5024,6 +5100,11 @@ static NTSTATUS allocate_virtual_memory( void **ret, SIZE_T *size_ptr, ULONG typ
     {
         *ret = base;
         *size_ptr = size;
+
+        /* if overcommit prevention is enabled and we performed a commit, then touch the commited pages */
+        if ((type & MEM_COMMIT) && overcommit_prevention_enabled()) {
+            touch_committed_pages(base, size, protect);
+        }
     }
     else if (status == STATUS_NO_MEMORY)
         ERR( "out of memory for allocation, base %p size %08lx\n", base, size );
@@ -5378,8 +5459,27 @@ NTSTATUS WINAPI NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T
         /* Make sure all the pages are committed */
         if (get_committed_size( view, base, size, &vprot, VPROT_COMMITTED ) >= size && (vprot & VPROT_COMMITTED))
         {
+            BOOL write_or_copy_added = FALSE;
             old = get_win32_prot( vprot, view->protect );
+            write_or_copy_added = 
+                (!has_write_flags(old) && has_write_flags(new_prot)) ||
+                (!has_writecopy_flags(old) && has_writecopy_flags(new_prot));
+
+            /* if overcommit prevention is enabled and write access is about to be granted then verify *
+             * that we have sufficient memory to write to the pages, since doing so may trigger the    *
+             * underlying operating system's copy-on-write mechanisms and increase physical memory use */
+            if (overcommit_prevention_enabled() && write_or_copy_added && memory_available_for_commit(size) == FALSE)
+            {
+                WARN("Prevented protection change due to insufficient memory.\n");
+                return STATUS_NO_MEMORY;
+            }
+
             status = set_protection( view, base, size, new_prot );
+
+            /* if overcommit prevention is enabled and write access was granted then touch the pages */
+            if (overcommit_prevention_enabled() && write_or_copy_added) {
+                touch_committed_pages(base, size, new_prot);
+            }
         }
         else status = STATUS_NOT_COMMITTED;
     }
diff --git a/server/Makefile.in b/server/Makefile.in
index 6e4e68d6ebfb6555b92afe6e9fa6e7422e6d0415..b2f0c27abcfc36abf15805acf900ce7a45a88978 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -48,6 +48,6 @@ SOURCES = \
 	winstation.c
 
 UNIX_CFLAGS = $(INOTIFY_CFLAGS)
-UNIX_LIBS   = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS)
+UNIX_LIBS   = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS) -lmemory-patches
 
 unicode_EXTRADEFS = -DBINDIR="\"${bindir}\"" -DDATADIR="\"${datadir}\""
diff --git a/server/file.c b/server/file.c
index 8f6566a0077dd77f56c48c98536e731fa1aeada6..4eb2b1bd1628db489420c01a3324cd55b3e6ba32 100644
--- a/server/file.c
+++ b/server/file.c
@@ -617,6 +617,8 @@ void file_set_error(void)
     case ENXIO:     set_error( STATUS_NO_SUCH_DEVICE ); break;
     case EXDEV:     set_error( STATUS_NOT_SAME_DEVICE ); break;
     case ELOOP:     set_error( STATUS_REPARSE_POINT_NOT_RESOLVED ); break;
+    case EFAULT:    set_error( STATUS_INVALID_ADDRESS ); break;
+    case ENOMEM:    set_error( STATUS_NO_MEMORY ); break;
 #ifdef EOVERFLOW
     case EOVERFLOW: set_error( STATUS_INVALID_PARAMETER ); break;
 #endif
diff --git a/server/mapping.c b/server/mapping.c
index 7edadcbbedaaff176ebb8a02411ecebaecef3df3..cd8037035cbe4418ae561df6940b41a7787bdb99 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -43,6 +43,8 @@
 #include "request.h"
 #include "security.h"
 
+#include <libmemory-patches.h>
+
 /* list of memory ranges, used to store committed info */
 struct ranges
 {
@@ -352,6 +354,41 @@ static int check_current_dir_for_exec(void)
     return (ret != MAP_FAILED);
 }
 
+
+/**************************************************************************************************/
+
+#ifdef __linux__
+
+/* create a memory-backed file for anonymous mappings */
+static int create_memfd_file( file_pos_t size )
+{
+    int fd;
+    
+    if (overcommit_prevention_enabled() && memory_available_for_commit(size) == FALSE)
+    {
+        set_error(STATUS_NO_MEMORY);
+        return -1;
+    }
+    
+    fd = memfd_create("wine_anonymous_mapping", 0);
+    if (fd == -1)
+    {
+        file_set_error();
+        return -1;
+    }
+    
+    if (ftruncate(fd, size) != 0)
+    {
+        file_set_error();
+        close( fd );
+        return -1;
+    }
+    
+    return fd;
+}
+
+#else
+
 /* create a temp file for anonymous mappings */
 static int create_temp_file( file_pos_t size )
 {
@@ -377,7 +414,17 @@ static int create_temp_file( file_pos_t size )
     fd = make_temp_file( tmpfn );
     if (fd != -1)
     {
-        if (!grow_file( fd, size ))
+        BOOL failed = FALSE;
+        if (overcommit_prevention_enabled() && is_memory_backed_file(fd) && memory_available_for_commit(size) == FALSE)
+        {
+            set_error(STATUS_NO_MEMORY);
+            failed = TRUE;
+        }
+        else {
+            failed = (grow_file( fd, size ) == 0);
+        }
+        
+        if (failed)
         {
             close( fd );
             fd = -1;
@@ -390,6 +437,11 @@ static int create_temp_file( file_pos_t size )
     return fd;
 }
 
+#endif
+
+/**************************************************************************************************/
+
+
 /* find a memory view from its base address */
 struct memory_view *find_mapped_view( struct process *process, client_ptr_t base )
 {
@@ -643,9 +695,18 @@ static int build_shared_mapping( struct mapping *mapping, size_t align_mask, int
 
     /* create a temp file for the mapping */
 
+    #ifdef __linux__
+    if ((shared_fd = create_memfd_file( total_size )) == -1) return 0;
+    #else
     if ((shared_fd = create_temp_file( total_size )) == -1) return 0;
+    #endif
+
     if (!(file = create_file_for_fd( shared_fd, FILE_GENERIC_READ|FILE_GENERIC_WRITE, 0 ))) return 0;
 
+    if (overcommit_prevention_enabled() && memory_available_for_commit(max_size) == FALSE)
+    {
+        goto error;
+    }
     if (!(buffer = malloc( max_size ))) goto error;
 
     /* copy the shared sections data into the temp file */
@@ -1088,7 +1149,13 @@ static struct mapping *create_mapping( struct object *root, const struct unicode
         }
         if ((flags & SEC_RESERVE) && !(mapping->committed = create_ranges())) goto error;
         mapping->size = round_size( mapping->size, page_mask );
+        
+        #ifdef __linux__
+        if ((unix_fd = create_memfd_file( mapping->size )) == -1) goto error;
+        #else
         if ((unix_fd = create_temp_file( mapping->size )) == -1) goto error;
+        #endif
+        
         if (!(mapping->fd = create_anonymous_fd( &mapping_fd_ops, unix_fd, &mapping->obj,
                                                  FILE_SYNCHRONOUS_IO_NONALERT ))) goto error;
         allow_fd_caching( mapping->fd );
@@ -1743,3 +1810,22 @@ DECL_HANDLER(get_mapping_filename)
 
     release_object( process );
 }
+
+DECL_HANDLER(get_fd_for_address)
+{
+    struct process *process;
+    struct memory_view *view;
+
+    if ((process = get_process_from_handle( req->process, PROCESS_QUERY_INFORMATION )))
+    {
+        if ((view = find_mapped_addr( process, req->addr )))
+        {
+            int unix_fd = get_unix_fd( view->fd );
+            send_client_fd(current->process, unix_fd, req->handle);
+        }
+        else set_error( STATUS_INVALID_ADDRESS );
+
+        release_object( process );
+    }
+    else set_error( STATUS_INVALID_HANDLE );
+}
